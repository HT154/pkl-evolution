= External Readers

* Proposal: link:./SPICE-0009-external-readers.adoc[SPICE-0009]
* Status: TBD
* Implemented in: Pkl 0.27 ()
* Category: Language

== Introduction

This SPICE proposes a way for custom module and resource readers to be used when evaluating modules with `pkl eval`.

== Motivation

When used via language binding libraries, custom module and resource readers schemes may be implemented by client code.
Custom readers help bridge Pkl into systems where it does't fit natively, enabling a wide variety of use cases:

* Mediating access to resources that require authentication (eg. a secret store)
* Querying data accessible via non-HTTP protocols (eg. LDAP)
* Providing filesystem abstractions for remote or in-memory modules
* And more!

One of the primary drawbacks to custom readers is that using one instantly turns a Pkl module into a _incompatible language_: the module may only be evaluated by the client tool or application providing the reader and can no longer be evaluated directly using `pkl eval`.
This hinders development and debugging of such modules, as typical workflows involving `trace(<expr>)` or `pkl eval -x '<expr>'` behave differently or are no longer possible.

== Proposed Solution

The existing message passing API and client libraries will be expanded to support external readers.
Instead of client libraries invoking `pkl server`, `pkl eval` invocations, when configured with an external reader, will run the reader executable as a subprocess.
External readers can provide any number of resource and/or module schemes and will be configured as an executable and list of arguments via:

* CLI flag
* PklProject property
* Java API
* Message passing API

[source,pkl]
----
/// May be specified as an absolute path to an executable
/// May also be specified as just an executable name, in which case it will be resolved according to the PATH environment variable
executable: String

/// Command line arguments that will be passed to the reader process
arguments: Listing<String>
----

=== Example

Consider this module:

[source,pkl]
----
username = "john_appleseed"

email = read("ldap://ds.example.com:389/dc=example,dc=com?mail?sub?(uid=\(username))").text
----

Pkl doesn't implement the `ldap:` resource URI scheme natively, but an external reader can provide it.
Assuming a hypothetical `pkl-ldap` binary implementing the external reader protocol and the `ldap:` scheme is in the `$PATH`, this module can be evaluated as:

[source,text]
----
$ pkl eval <module> --external-reader=pkl-ldap --allowed-resources prop:,ldap:
username = "john_appleseed"
email = "appleseed@example.com"
----

For security reasons, schemes provided by external readers are not allowed by default and clients must explicitly allow the desired scheme(s).
In this example, the external reader may provide both `ldap:` and `ldaps:` schemes.
If a codebase or user wishes to enforce that only secure LDAP connections are made, the `ldaps:` scheme may be allowed while `ldap:` is not.

== Detailed design

To avoid terminology confusion with the existing language binding message passing model, the `pkl` process will remain known as the "server" and the reader process will be known as the "client", despite all requests in this proposal being initiated by the `pkl` process.

* Message Passing API
** Add DiscoverReadersRequest
** Add DiscoverReadersResponse
** CreateEvaluatorRequest
*** `externalReaders`
** Pull into a new pkl-msgapi(?) package shared by pkl-code and pkl-server
*** Message*.kt files at least

* Java API
** New `ExternalModuleKeyFactory` type
*** Entrypoints (CLI, Server) construct based on `externalReaders`
*** On (initialization? explicit startup?), launch subprocess
*** send each DiscoverReadersRequest, await DiscoverReadersResponse (timeout? 1s?)

* stdlib
** `pkl:EvaluatorSettings` (used in `pkl:Project`)
*** `externalReaders: Listing<ExternalReader>`

* CLI
** `--external-reader`
*** use `clikt.multiple`
*** may be passed as a space-separated string where the first element becomes `executable` and any remainder becomes `arguments`
*** should this be shlex'd? or just split on spaces?

* Language Bindings
** Add `ExternalReaderRuntime`
** Add `externalReaders` to `EvaluatorOptions`

== Compatibility

This proposal is purely additive.

In the case where newer language bindings configure external readers against an older `pkl` binary, the new `CreateEvaluatorRequest.externalReaders` field will be ignored silently. If module evaluation relies on configured external readers, it will fail accordingly.

== Future directions

* Support for specifying URIs for external reader executables so they may be distributed in Pkl packages.
This is potentially very valuable for statically compiled reader binaries, but significantly complicates the implementation.
The design, as proposed, does not prohibit implementing this as a future enhancement.
This would also make it very convenient to provide friendly, type-safe Pkl APIs for complex reader URI schemes instead of having the "stringly-typed" URI as the primary API, e.g. building on the `ldap:` example:
+
[source,pkl]
----
typealias LDAPResult = Mapping<String, Listing<String>>

class LDAPQuery {
    protocol: *"ldap"|"ldaps"
    host: String
    port: UInt16 = 389
    baseDN: String
    attributes: Listing<String>
    scope: *"base"|"one"|"sub"
    filter: String = "(&)" // matches anything

    fixed results: Listing<LDAPResult> = new json.Parser { useMapping = true }.parse(
        read("\(protocol)://\(host):\(port)/\(baseDN)?\(attributes.join(","))?\(scope)?\(filter)").text
    )
}

local queryResults = new LDAPQuery {
    host = "ds.example.com"
    baseDN = "dc=example,dc=com"
    attributes { "mail" }
    scope = "sub"
    filter = "(uid=\(username))"
}.results

username = "john_appleseed"

email = queryResults[0]["mail"][0]
----
* Java library for bindings to support being an external reader client
* To improve CLI ergonomics, could implement additive `--allow-resources`/`--allow-modules` args (current flags replace full list)
* Manage external reader processes separately from EvaluatorImpl lifetime
** Potential large savings in per-evaluator overhead for Java API and Language Binding usage
** Savings for CLI usage (primary use case) would be minimal
** Code is more complicated (need an ExternalReaderManager sort of mechanism tracking unique commands => processes)
** Change could be made as followup work with only changes to Java APIs and internals

== Alternatives considered

=== One shot, per-read subprocesses

Instead of "persistent" reader processes invoked during evaluator initialization.
Instead of using the msgpack message-passing API, reader binaries could be invoked with the read URI as a CLI argument and return their result on standard output.
This potentially greatly lowers the barrier to entry for implementing external readers, even allowing them to be implemented by shell scripts.

This approach does not have a clean way to support globbed reads.
To resolve globs, Pkl can require many list modules/resources requests.
It's not clear one-shot reader processes would be invoked differently to distinguish read requests from list requests.
Multiple invocations would also have potentially significant overhead, especially for readers implemented in interpreted languages.

There is definitely value in supporting significantly reduced barrier to reader implementation, especially when globbing is not required.
One way this gap might be closed is with a "shim" reader process that translates the message passing API calls to subprocess invocations:

[source,text]
----
$ pkl eval <module> --external-reader 'pkl-cmd ldap=pkl-ldap.sh' --allowed-resources prop:,ldap:
username = "john_appleseed"
email = "appleseed@example.com"
----

It may even make sense for the `pkl` binary itself to provide this functionality.

=== Up-front scheme -> reader registration

Instead of Pkl starting reader subprocesses and discovering supported schemes during evaluator initialization, an alternative approach would be to explicit register this mapping.
This would allow reader processes to be launched on first read instead of during evaluator initialization.
This is more efficient in cases where the reader is not actually needed, but requires a greater amount of up-front configuration, especially when the same reader executable will be used for multiple schemes.

[source,text]
----
$ pkl eval <module> --external-resource-reader ldap=pkl-ldap --allowed-resources prop:,ldap:
username = "john_appleseed"
email = "appleseed@example.com"
----

This approach raises a few questions:

* Should declaring an external reader automatically allow reads for its scheme?
Declaring explicit allowed resources should probably disable this behavior.
* What happens when a reader doesn't support the scheme it is declared for?
