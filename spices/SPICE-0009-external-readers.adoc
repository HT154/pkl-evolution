= External Readers

* Proposal: link:./SPICE-0009-external-readers.adoc[SPICE-0009]
* Status: TBD
* Implemented in: Pkl 0.27 ()
* Category: Language

== Introduction

This SPICE proposes a way for custom module and resource readers to be used when evaluating modules with `pkl eval`.

== Motivation

When used via language binding libraries, custom module and resource readers schemes may be implemented by client code.
Custom readers help bridge Pkl into systems where it does't fit natively, enabling a wide variety of use cases:

* Mediating access to resources that require authentication (eg. a secret store)
* Querying data accessible via non-HTTP protocols (eg. LDAP)
* Providing filesystem abstractions for remote or in-memory modules
* And more!

One of the primary drawbacks to custom readers is that using one instantly turns a Pkl module into a _incompatible language_: the module may only be evaluated by the client tool or application providing the reader and can no longer be evaluated directly using `pkl eval`.
This hinders development and debugging of such modules, as typical workflows involving `trace(<expr>)` or `pkl eval -x '<expr>'` behave differently or are no longer possible.

== Proposed Solution

The existing message passing API and client libraries will be expanded to support external readers.
Instead of client libraries invoking `pkl server`, `pkl eval` invocations, when configured with an external reader, will run the reader executable as a subprocess.
External readers can provide any number of resource and/or module schemes and will be configured as an executable and list of arguments via:

* CLI flag
* PklProject property
* Java API
* Message passing API

[source,pkl]
----
/// May be specified as an absolute path to an executable
/// May also be specified as just an executable name, in which case it will be resolved according to the PATH environment variable
executable: String

/// Command line arguments that will be passed to the reader process
arguments: Listing<String>
----

=== Example

Consider this module:

[source,pkl]
----
username = "john_appleseed"

email = read("ldap://ds.example.com:389/dc=example,dc=com?mail?sub?(uid=\(username))").text
----

Pkl doesn't implement the `ldap:` resource URI scheme natively, but an external reader can provide it.
Assuming a hypothetical `pkl-ldap` binary implementing the external reader protocol and the `ldap:` scheme is in the `$PATH`, this module can be evaluated as:

[source,text]
----
$ pkl eval <module> --external-reader=pkl-ldap --allowed-resources prop:,ldap:
username = "john_appleseed"
email = "appleseed@example.com"
----

For security reasons, schemes provided by external readers are not allowed by default and clients must explicitly allow the desired scheme(s).
In this example, the external reader may provide both `ldap:` and `ldaps:` schemes.
If a codebase or user wishes to enforce that only secure LDAP connections are made, the `ldaps:` scheme may be allowed while `ldap:` is not.

== Detailed design

To avoid terminology confusion with the existing language binding message passing model, the `pkl` process will remain known as the "server" and the reader process will be known as the "client", despite all requests in this proposal being initiated by the `pkl` process.

=== Overall Flow

1. User requests an evaluator (via Java API, Message Passing API, or CLI) with an external reader.
2. Entrypoint (client Java code, `CliEvaluator`, or `Server`) instantiates an `ExternalReader`.
3. The `ExternalReader` is started, which starts the configured child process and sends a `DiscoverReadersRequest` message.
4. A `DiscoverReadersResponse` message is received (within some timeout).
5. The entrypoint requests resource readers (`ExternalResourceReader`) and module key factories (`ExternalModuleKeyFactory`) from the `ExternalReader` and uses them to build an evaluator.
`ExternalResourceReader` and `ExternalModuleKeyFactory` function similarly to the existing `ClientResourceReader` and `ClientModuleKeyFactory`, implementation may be reusable entirely.
6. Evaluation begins.
7. A resource or module read is encountered.
8. The appropriate `Read*Request` message is sent to the child process, the corresponding `Read*Response` message is awaited.
9. Evaluation continues.
10. Evaluation completes.
11. The `ExternalReader` is closed, the child process is sent SIGTERM.
12. If the child process has not terminated after some timeout (3 seconds?), it is forcefully stopped via SIGKILL.

=== Java API

New APIs:

* `ExternalResourceReader` - a `ResourceReader` implementation similar (identical?) to `ClientResourceReader`.
* `ExternalModuleKeyFactory` - a `ModuleKeyFactory` implementation similar (identical?) to `ClientModuleKeyFactory`.
* `ExternalModuleKey` - a `ModuleKey` implementation similar (identical?) to `ClientModuleKey`.
* `ExternalReader` - manages the lifecycle of child processes.
    ** Explicit `open`/`close` methods to manage child process lifecycle.
    ** Opening an `ExternalReader` spawns the subprocess, sets up the `MessageTransport`, sends a `DiscoverReadersRequest` message, and awaits a `DiscoverReadersResponse` response.
    ** Methods to procure `ExternalResourceReader` and `ExternalModuleKeyFactory` instances.

This proposal requires that the message passing API functionality move out of pkl-server and into pkl-core.
The code added to pkl-core will include the new APIs and the core messaging code currently part of pkl-server (`pkl-server/src.main/kotlin/org.pkl.server/Message*.kt`).

=== Message Passing API

Two new message types will be added:

[source,pkl]
----
/// Code: 0x2e
/// Type: Server Request
class DiscoverReadersRequest {
  /// A number identifying this request
  requestId: Int
}

/// Code: 0x2f
/// Type: Client Response
class DiscoverReadersResponse {
  /// A number identifying this request
  requestId: Int

  /// Register client-side module readers.
  ///
  /// [ClientModuleReader] is defined at https://pkl-lang.org/main/current/bindings-specification/message-passing-api.html#create-evaluator-request
  clientModuleReaders: Listing<ClientModuleReader>?

  /// Register client-side resource readers.
  ///
  /// [ClientResourceReader] is defined at https://pkl-lang.org/main/current/bindings-specification/message-passing-api.html#create-evaluator-request
  clientResourceReaders: Listing<ClientResourceReader>?
}
----

`CreateEvaluatorRequest` will be expanded with an additional property:
[source,pkl]
----
externalReaders: Listing<ExternalReader>?

class ExternalReader {
  /// May be specified as an absolute path to an executable
  /// May also be specified as just an executable name, in which case it will be resolved according to the PATH environment variable
  executable: String

  /// Command line arguments that will be passed to the reader process
  arguments: Listing<String>
}
----

=== CLI

A new `--external-reader` CLI argument will be added to configure external readers.
This argument can be provided multiple times (using `clikt.multiple`) to configure multiple external readers.
The argument may be passed as a space-separated string where the first element becomes `executable` and any remainder becomes `arguments`.

TBD: It might be best if the argument value is link:https://docs.python.org/3/library/shlex.html#shlex.split[shlex'd] instead of split to support passing arguments to the reader process that contain spaces.

=== Standard Library

The `EvaluatorSettings` module will be expanded to enable configuring external readers in `PklProject` files:

[source,pkl]
----
externalReaders: Listing<ExternalReader>?

class ExternalReader {
  /// May be specified as an absolute path to an executable
  /// May also be specified as just an executable name, in which case it will be resolved according to the PATH environment variable
  executable: String

  /// Command line arguments that will be passed to the reader process
  arguments: Listing<String>
}
----

=== Language Binding Libraries

The language binding libraries `pkl-go` and `pkl-swift` will be expanded to support using and implementing external readers.
For the purpose of illustration, examples will be provided using Golang.

The `EvaluatorOptions` type will be expanded to include a new property for external readers:

[source,go]
----
type EvaluatorOptions struct {
	// ...
    ExternalReaders []ExternalReader
	// ...
}

type ExternalReader struct {
	Executable string
	Arguments []string
}
----

A new `ExternalReaderRuntime` type will be introduced to implement the child process message passing interface.
It makes sense to expand the existing libraries to add this functionality as much of the message passing infrastructure and types for implementing resource and module readers can be reused.
An `ExternalReaderRuntime` is configured with zero or more `ResourceReader` instances and zero or more `ModuleReader`.
When started, the runtime will consume messages from the configured `Reader`, dispatch calls to the configured readers, and send responses to the configured `Writer`.

[source,go]
----
type ExternalReaderRuntime interface {
  Run()
  Close()
}

type ExternalReaderRuntimeOptions struct {
	// ResourceReaders are the resource readers to be used by the evaluator.
	ResourceReaders []ResourceReader

	// ModuleReaders are the set of custom module readers to be used by the evaluator.
	ModuleReaders []ModuleReader

	// Input reader to consume messages from Pkl from
	// Defaults to os.Stdin if not set
	Input io.Reader

	// Output writer to produce message to Pkl
	// Defaults to os.Stdout if not set
	Output io.Writer
}

func NewExternalReaderRuntime(opts ...func(options *ExternalReaderRuntimeOptions)) ExternalReaderRuntime {
  // ...
}

var WithResourceReaders = // ...
var WithModuleReaders = // ...
var WithStreams = // ...
----

== Compatibility

From a language perspective, this proposal is purely additive.

In the case where newer language bindings configure external readers against an older `pkl` binary, the new `CreateEvaluatorRequest.externalReaders` field will be ignored silently.
If module evaluation relies on configured external readers, it will fail accordingly.

Any usage of the pkl-server APIs that are moving to pkl-core will break.
It's unlikely there are clients of these APIs outside the apple/pkl repo.

== Future directions

* Support for specifying URIs for external reader executables so they may be distributed in Pkl packages.
This is potentially very valuable for statically compiled reader binaries, but significantly complicates the implementation.
The design, as proposed, does not prohibit implementing this as a future enhancement.
This would also make it very convenient to provide friendly, type-safe Pkl APIs for complex reader URI schemes instead of having the "stringly-typed" URI as the primary API, e.g. building on the `ldap:` example:
+
[source,pkl]
----
import "pkl:json"

typealias LDAPResult = Mapping<String, Listing<String>>

class LDAPQuery {
    protocol: *"ldap"|"ldaps"
    host: String
    port: UInt16 = 389
    baseDN: String
    attributes: Listing<String>
    scope: *"base"|"one"|"sub"
    filter: String = "(&)" // matches anything

    fixed results: Listing<LDAPResult> = new json.Parser { useMapping = true }.parse(
        read("\(protocol)://\(host):\(port)/\(baseDN)?\(attributes.join(","))?\(scope)?\(filter)").text
    )
}

local queryResults = new LDAPQuery {
    host = "ds.example.com"
    baseDN = "dc=example,dc=com"
    attributes { "mail" }
    scope = "sub"
    filter = "(uid=\(username))"
}.results

username = "john_appleseed"

email = queryResults[0]["mail"][0]
----
* Java library for bindings to support being an external reader client
* To improve CLI ergonomics, could implement additive `--allow-resources`/`--allow-modules` args (current flags replace full list)
* Manage external reader processes separately from EvaluatorImpl lifetime
** Potential large savings in per-evaluator overhead for Java API and Language Binding usage
** Savings for CLI usage (primary use case) would be minimal
** Code is more complicated (need an ExternalReaderManager sort of mechanism tracking unique commands => processes)
** Change could be made as followup work with only changes to Java APIs and internals

== Alternatives considered

=== One shot, per-read subprocesses

Instead of "persistent" reader processes invoked during evaluator initialization.
Instead of using the msgpack message-passing API, reader binaries could be invoked with the read URI as a CLI argument and return their result on standard output.
This potentially greatly lowers the barrier to entry for implementing external readers, even allowing them to be implemented by shell scripts.

This approach does not have a clean way to support globbed reads.
To resolve globs, Pkl can require many list modules/resources requests.
It's not clear one-shot reader processes would be invoked differently to distinguish read requests from list requests.
Multiple invocations would also have potentially significant overhead, especially for readers implemented in interpreted languages.

There is definitely value in supporting significantly reduced barrier to reader implementation, especially when globbing is not required.
One way this gap might be closed is with a "shim" reader process that translates the message passing API calls to subprocess invocations:

[source,text]
----
$ pkl eval <module> --external-reader 'pkl-cmd ldap=pkl-ldap.sh' --allowed-resources prop:,ldap:
username = "john_appleseed"
email = "appleseed@example.com"
----

It may even make sense for the `pkl` binary itself to provide this functionality.

=== Up-front scheme -> reader registration

Instead of Pkl starting reader subprocesses and discovering supported schemes during evaluator initialization, an alternative approach would be to explicit register this mapping.
This would allow reader processes to be launched on first read instead of during evaluator initialization.
This is more efficient in cases where the reader is not actually needed, but requires a greater amount of up-front configuration, especially when the same reader executable will be used for multiple schemes.

[source,text]
----
$ pkl eval <module> --external-resource-reader ldap=pkl-ldap --allowed-resources prop:,ldap:
username = "john_appleseed"
email = "appleseed@example.com"
----

This approach raises a few questions:

* Should declaring an external reader automatically allow reads for its scheme?
Declaring explicit allowed resources should probably disable this behavior.
* What happens when a reader doesn't support the scheme it is declared for?
